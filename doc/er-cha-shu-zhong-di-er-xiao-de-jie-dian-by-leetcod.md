##  解决方法：
####  方法一：暴力法 [通过]

**算法：**
- 通过深度优先搜索遍历树，并使用集合结构唯一性记录树中的每个唯一值。 
- 然后，我们将查看第二个最小值的记录值。第一个最小值必须是 ![\textroot.val ](./p__text_root.val_.png) 。 


**复杂度分析**

* 时间复杂度：*O(N)*。其中 *N* 是给定树中的节点总数。我们只访问每个节点一次。
* 空间复杂度：*O(N)*，存储在 *uniques* 中的信息。 


####  方法二：
**算法：**
- 让 ![\text{min1=root.val} ](./p__text{min1_=_root.val}_.png) 。当遍历结点 ![\text{node} ](./p__text{node}_.png) ，如果 ![\text{node.val>min1} ](./p__text{node.val___min1}_.png) ，我们知道在 ![\text{node} ](./p__text{node}_.png)  处的子树中的所有值都至少是 ![\text{node.val} ](./p__text{node.val}_.png) ，因此在该子树中不此存在第二个最小值。因此，我们不需要搜索这个子树。
- 此外，由于我们只关心第二个最小值  ![\text{ans} ](./p__text{ans}_.png) ，因此我们不需要记录任何大于当前第二个最小值的值，因此与方法 1 不同，我们可以完全不用集合存储数据。  

**复杂度分析**

* 时间复杂度：*O(N)*。其中 *N* 是给定树中的节点总数。我们最多访问每个节点一次。 
* 空间复杂度：*O(N)*，存储在 ![\text{ans} ](./p__text{ans}_.png)  和 ![\text{min1} ](./p__text{min1}_.png)  中的信息为 *O(1)*，但我们的深度优先搜索可能会在调用堆栈中存储多达 *O(h) = O(N)* 的信息，其中 *h* 是树的高度。