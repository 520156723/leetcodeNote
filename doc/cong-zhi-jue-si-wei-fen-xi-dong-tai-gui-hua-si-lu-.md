#### 假设 n = 5，有 5 级楼梯要爬
- 题意说，每次有2种选择：爬1级，或爬2级。
  - 如果爬1级，则剩下4级要爬。
  - 如果爬2级，则剩下3级要爬。
- 这拆分出了2个子问题：
  - 爬4级楼梯有几种方式？
  - 爬3级楼梯有几种方式？
- 于是，爬 5 级楼梯的方式数 = 爬 4 级楼梯的方式数 + 爬 3 级楼梯的方式数。
#### 画出递归树
- 用「剩下要爬的楼梯数」作为节点值。

![image.png](https://pic.leetcode-cn.com/71299a4f6073fc57a5ad9a58f359f65b6036792974cf984c114f3e795b81d0ac-image.png)

- 子节点又会面临2个选择，不断分支，直到遍历到位于递归树底部的 base case：
  - 楼梯数为 0 时，只有 1 种选择：什么都不做。
  - 楼梯数为 1 时，只有1种选择：爬1级。

![image.png](https://pic.leetcode-cn.com/3b94631946f5d66def53d3e0d83d688b1f974e48a4e373ff35411051e5b7a2ae-image.png)

- 递归遍历到 base case，解是已知的，开始返回，如下图，子问题的结果不断向上返回，得到父问题的解。

![image.png](https://pic.leetcode-cn.com/6486420fe6a2d3c7d747f2d79593972a4d09f35562382bafd151a556f2771b31-image.png)
- 调用栈的深度是楼梯数 n，空间复杂度是*O(n)*，时间复杂度最坏是*O(2^n)*，所有节点都遍历到。
#### 存在重复的子问题
- 如下图，黄色阴影部分，蓝色阴影部分，就是相同的子树，即相同的子问题。

![image.png](https://pic.leetcode-cn.com/1656fbbbb9f8cb9230ffcbd6bfd34b7beb5d29f7cbee495056b4c0a90f81735f-image.png)

- 子问题的计算结果可以存储在哈希表中，或者数组，下次遇到就不用再进入相同的递归。
- 去除重复的计算后的子树如下，时间复杂度降到了O(n)，空间复杂度O(n)。

![image.png](https://pic.leetcode-cn.com/233388864ab96549ba7b60cdb73237f4881cdc07e9a7ac886dc5f95609ab8efc-image.png)
#### 动态规划，自底而上思考
- 我们发现，*爬 i 层楼梯的方式数 =  爬 i-2 层楼梯的方式数 + 爬 i-1 层楼梯的方式数*。
- 我们有两个 base case，结合上面的递推式，就能递推出爬 i 层楼梯的方式数。
- 用一个数组 dp 存放中间子问题的结果。
- dp[i]：爬 i 级楼梯的方式数。从dp[0]、dp[1]出发，顺序计算，直到算出 dp[i]，就像填表格。

![image.png](https://pic.leetcode-cn.com/e60b159161ba4a32967a087fb1fc5b25356fc506f2eff197b19deb34e9053653-image.png)
#### 代码
```javascript
const climbStairs = (n) => {
  const dp = new Array(n + 1).fill(0);
  dp[0] = 1;
  dp[1] = 1;
  for (let i = 2; i < dp.length; i++) {
    dp[i] = dp[i - 2] + dp[i - 1];
  }
  return dp[n];
}
```
#### 压缩空间，优化
dp[i] 只与过去的两项：dp[i-1] 和  dp[i-2] 有关，没有必要存下所有计算过的 dp 项。用两个变量去存这两个过去的状态就好。
```js 
const climbStairs = (n) => {
  let prev = 1;
  let cur = 1;
  for (let i = 2; i < n + 1; i++) {
    const temp = cur;   // 暂存上一次的cur
    cur = prev + cur;   // 当前的cur = 上上次cur + 上一次cur
    prev = temp;        // prev 更新为 上一次的cur
  }
  return cur;
}
```
####
> ##### 我搜DP和递归的区别时，发现 “一亩三分地” 的一篇上古帖： [面试准备关键在于掌握方法，而不是刷题](https://www.1point3acres.com/bbs/thread-130162-1-1.html)，里面有大佬互怼。我也引用了一些内容如下，适合我理解，仅供参考：
#### 可以用动态规划的问题都能用递归
- 从子问题入手，解决原问题，分两种做法：自顶向下和自底向上
- 前者对应递归，借助函数调用自己实现，是程序解决问题的方式，它不会记忆解
- 后者对应DP，利用迭代将结果存在数组里，从数组0位开始顺序往后计算
- 递归的缺点在于包含重复的子问题，DP 的效率更高
#### DP也有局限性
- DP 相比于 递归，有时候不太好理解，或者边界情况比较难确定
- 而且必须是一步步邻接的，连续地计算
- 结合了记忆化的递归，灵活很多，它在递归基础上稍作修改即可，有时候更好理解，也少了局限性，不好用DP时一定能用它
- 比如有时候要求出达到某个结果的路径，这时递归（DFS）回溯出路径，显然更有优势

#### 本篇经过反复修改打磨，应该是流畅好懂了，相信你也感受到这份诚意，如果有帮助，点个赞鼓励我继续写下去，如果哪里写得不对写得不好，指出我我继续修改
