//åœ¨æ•´æ•°æ•°ç»„ nums ä¸­ï¼Œæ˜¯å¦å­˜åœ¨ä¸¤ä¸ªä¸‹æ ‡ i å’Œ jï¼Œä½¿å¾— nums [i] å’Œ nums [j] çš„å·®çš„ç»å¯¹å€¼å°äºç­‰äº t ï¼Œä¸”æ»¡è¶³ i å’Œ j çš„å·®çš„
//ç»å¯¹å€¼ä¹Ÿå°äºç­‰äº Ä· ã€‚ 
//
// å¦‚æœå­˜åœ¨åˆ™è¿”å› trueï¼Œä¸å­˜åœ¨è¿”å› falseã€‚ 
//
// 
//
// ç¤ºä¾‹ 1: 
//
// è¾“å…¥: nums = [1,2,3,1], k = 3, t = 0
//è¾“å‡º: true 
//
// ç¤ºä¾‹ 2: 
//
// è¾“å…¥: nums = [1,0,1,1], k = 1, t = 2
//è¾“å‡º: true 
//
// ç¤ºä¾‹ 3: 
//
// è¾“å…¥: nums = [1,5,9,1,5,9], k = 2, t = 3
//è¾“å‡º: false 
// Related Topics æ’åº Ordered Map 
// ğŸ‘ 301 ğŸ‘ 0


import java.util.TreeSet;

//leetcode submit region begin(Prohibit modification and deletion)
class Solution {
    public boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t) {
        TreeSet<Long> set = new TreeSet<>();//è‡ªç„¶æ’åº
        for (int i = 0; i < nums.length; ++i) {
            Long s = set.ceiling((long)nums[i]);//ä»setä¸­æ‰¾åˆ°ç¬¬ä¸€ä¸ªå¤§äºç­‰äºnum[i]çš„å…ƒç´ 
            if (s != null && s - nums[i] <= t)
                return true;
            Long g = set.floor((long)nums[i]);//ä»setä¸­æ‰¾åˆ°ç¬¬ä¸€ä¸ªå°äºç­‰äºnum[i]çš„å…ƒç´ 
            if (g != null && nums[i] - g <= t)
                return true;
            set.add((long)nums[i]);
            if (set.size() > k)
                set.remove((long)nums[i - k]);
        }
        return false;

    }


    /*private long getID(long x, long w) {
        return x < 0 ? (x + 1) / w - 1 : x / w;
    }

    public boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t) {
        if (t < 0) return false;
        Map<Long, Long> d = new HashMap<>();
        long w = (long)t + 1;
        for (int i = 0; i < nums.length; ++i) {
            long m = getID(nums[i], w);
            // check if bucket m is empty, each bucket may contain at most one element
            if (d.containsKey(m))
                return true;
            // check the nei***or buckets for almost duplicate
            if (d.containsKey(m - 1) && Math.abs(nums[i] - d.get(m - 1)) < w)
                return true;
            if (d.containsKey(m + 1) && Math.abs(nums[i] - d.get(m + 1)) < w)
                return true;
            // now bucket m is empty and no almost duplicate in nei***or buckets
            d.put(m, (long)nums[i]);
            if (i >= k) d.remove(getID(nums[i - k], w));
        }
        return false;
    }*/
}
//leetcode submit region end(Prohibit modification and deletion)
